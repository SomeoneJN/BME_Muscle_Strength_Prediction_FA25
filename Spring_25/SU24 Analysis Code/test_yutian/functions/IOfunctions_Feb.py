# Author: Yutian Yang
# Created: 5/15/2023
# Description: This is a file of all the IO functions that edited fot .feb file
# from what was written for the .inp file before
# Version: 1.0
# Email: yyt542985333@gmail.com
#--------------------------------------------------------------
# [Additional comments or notes]
#--------------------------------------------------------------

import xml.etree.ElementTree as ET
import shutil

import numpy as np

# from lib.workingWith3dDataSets import DataSet3d


def extract_Nodes_from_feb(file_name, node_name, nodes_list):
    """
    Extracts the coordinates of the specified nodes from a given part in an Abaqus input file.

    Parameters:
        file_name (str): The name of the .inp file.
        node_name (str): The name of the node from which nodes should be extracted.
        nodes_list (list): A list of node numbers to be extracted.

    Returns:
        list: A list of node coordinates.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and extracts the coordinates
        of the specified nodes from the given 'part'. The node coordinates are extracted from the 'TissueCoordinates'
        array generated by calling the 'extractPointsForPartFrom' function.

        The function iterates over the provided 'nodes' list and retrieves the coordinates for each node from the
        'TissueCoordinates' array. The extracted node coordinates are added to the 'NodeCoordinates' list.

        The function returns a list of node coordinates.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> nodes = [1, 3, 5]
        >>> node_coordinates = extract_Nodes_from_feb(file_name, part, nodes)
        >>> print(node_coordinates)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
    """

    all_coordinates = extract_coordinates_list_from_feb(file_name, node_name)
    extract_coordinates = []
    for i in nodes_list:
        extract_coordinates.append(all_coordinates[i - 1])
    return extract_coordinates


def extract_coordinates_list_from_feb(file_name, node_name, get_connections=False):
    """
    Extracts the coordinates of nodes from an FEB file and returns them as a list.

    Parameters:
    - file_name (str): The name of the FEB file to extract coordinates from.
    - node_name (str): The name of the node element in the FEB file.
    - get_connections (bool, optional): Whether to also extract the connections between nodes. Default is False.

    Returns:
    - points_list (list): A list containing the coordinates of nodes as tuples.

    Description:
    This function parses the XML file specified by 'file_name' and searches for the 'Nodes' element with the given
    'node_name'. If found, it iterates over each 'node' element within the 'Nodes' element and extracts the
    coordinates.

    The extracted coordinates are converted to floating-point numbers and stored as tuples in the 'points_list'.
    Each tuple represents the 3D coordinates of a node.

    If the 'get_connections' parameter is set to True, the function can also extract the connections between nodes,
    but this functionality is not implemented in the provided code.

    If no 'Nodes' element with the specified 'node_name' is found, an appropriate error message is printed, and
    an empty list is returned.

    Example usage:
    >>> extract_coordinates_list_from_feb('input.feb', 'MyNodes', get_connections=True)
    """

    tree = ET.parse(file_name)
    root = tree.getroot()

    points_list = []  # an empty list
    connection_dic = {}  # an empty dictionary

    # Convert the XML tree into a list
    xml_elements = list(root.iter())

    # Find the 'Nodes' element with the target_name attribute
    for i, element in enumerate(xml_elements):
        if element.tag == "Nodes" and element.attrib.get('name') == node_name:
            for node in element.iter('node'):
                points_list.append(tuple(float(coordinate) for coordinate in node.text.split(',')))

            # If get_connections is True, also extract the 'elem' data from the next 'Elements' section
            if get_connections:
                for next_element in xml_elements[i + 1:]:
                    if next_element.tag == "Elements":
                        for elem in next_element.iter('elem'):
                            temp_list = list(map(int, elem.text.split(',')))
                            connection_dic[temp_list[0]] = temp_list[1:]
                        break
            break

    if not points_list:
        print(f"No 'Nodes' element with the name '{node_name}' found.")

    if get_connections:
        return points_list, connection_dic
    else:
        return points_list


def extract_coordinates_list_from_feb2(file_name, node_name, get_connections=False):
    """
    Extracts the coordinates of nodes from an FEB file and returns them as a list. Optionally, it can also extract the connections between nodes.

    Parameters:
        file_name (str): The name of the FEB file to extract coordinates from.
        node_name (str): The name of the node element in the FEB file.
        get_connections (bool, optional): Whether to also extract the connections between nodes. Default is False.

    Returns:
        list: A tuple containing the coordinates list and connection list (if get_connections is True),
        or just the coordinates list (if get_connections is False).

    Description:
        This function parses the XML file specified by 'file_name' and searches for the 'Nodes' element with the given 'node_name'. If found, it extracts the coordinates of each 'node' element within the 'Nodes' element and stores them in the 'points_list'.

        If the 'get_connections' parameter is set to True, the function can also extract the connections between nodes by searching for the 'Elements' section after the 'Nodes' section. The connections are stored in the 'connection_list'.

        If no 'Nodes' element with the specified 'node_name' is found, an appropriate error message is printed, and an empty list is returned.

    Example usage:
        >>> extract_coordinates_list_from_feb2('input.feb', 'MyNodes', get_connections=True)
    """
    tree = ET.parse(file_name)
    root = tree.getroot()

    points_list = []  # an empty list
    connection_list = []

    # Convert the XML tree into a list
    xml_elements = list(root.iter())

    # Find the 'Nodes' element with the target_name attribute
    for i, element in enumerate(xml_elements):
        if element.tag == "Nodes" and element.attrib.get('name') == node_name:
            for node in element.iter('node'):
                points_list.append(tuple(float(coordinate) for coordinate in node.text.split(',')))

            # If get_connections is True, also extract the 'elem' data from the next 'Elements' section
            if get_connections:
                for next_element in xml_elements[i + 1:]:
                    if next_element.tag == "Elements":
                        for elem in next_element.iter('elem'):
                            temp_list = list(map(int, elem.text.split(',')))
                            connection_list.append(temp_list)
                        break
            break

    if not points_list:
        print(f"No 'Nodes' element with the name '{node_name}' found.")

    if get_connections:
        return points_list, connection_list
    else:
        return points_list


def extract_node_id_list_from_feb(file_name, node_name):
    """
    Extracts the IDs of nodes from an FEB file and returns them as a list.

    Parameters:
        file_name (str): The name of the FEB file to extract node IDs from.
        node_name (str): The name of the node element in the FEB file.

    Returns:
        list: A list containing the IDs of nodes.

    Description:
        This function parses the XML file specified by 'file_name' and searches for the 'Nodes' element with the given 'node_name'. If found, it extracts the 'id' attribute of each 'node' element within the 'Nodes' element and stores them in the 'node_id_list'.

        If the 'get_connections' parameter is set to True, the function can also extract the connections between nodes, but this functionality is not implemented in the provided code.

        If no 'Nodes' element with the specified 'node_name' is found, an appropriate error message is printed, and an empty list is returned.

    Example usage:
        >>> extract_node_id_list_from_feb('input.feb', 'MyNodes', get_connections=True)
    """

    tree = ET.parse(file_name)
    root = tree.getroot()

    node_id_list = []  # an empty list

    # Find the 'Nodes' element with the target_name attribute
    nodes_element = root.find(f".//Nodes[@name='{node_name}']")

    # Check if the 'Nodes' element is found
    if nodes_element is not None:
        # Iterate over each 'node' element in the found 'Nodes' element
        # for node in nodes_element.iter('node'):
        #     node_id_list.append(tuple(float(coordinate) for coordinate in node.text.split(',')))

        node_id_list = [node.attrib['id'] for node in nodes_element.findall('node')]
    else:
        print(f"No 'Nodes' element with the name '{node_name}' found.")
    return node_id_list


def extract_coordinates_dic_from_feb(file_name, node_name):
    """
    Extracts the coordinates of nodes from an FEB file and returns them as a dictionary.

    Parameters:
    - file_name (str): The name of the FEB file to extract coordinates from.
    - node_name (str): The name of the node element in the FEB file.

    Returns:
    - nodes_dictionary (dict): A dictionary containing node IDs as keys and coordinates as values.

    Description:
    This function parses the XML file specified by 'file_name' and searches for the 'Nodes' element with the given
    'node_name'. If found, it iterates over each 'node' element within the 'Nodes' element, extracts the ID and
    coordinates of the node, and stores them in the 'nodes_dictionary' dictionary.

    The ID of each node is converted to an integer, and the coordinates are stored as a list of floats.

    If the 'get_connections' parameter is set to True, the function can also extract the connections between nodes,
    but this functionality is not implemented in the provided code.

    If no 'Nodes' element with the specified 'node_name' is found, an appropriate error message is printed, and
    an empty dictionary is returned.

    Example usage:
    >>> extract_coordinates_dic_from_feb('input.feb', 'MyNodes', get_connections=True)
    """
    tree = ET.parse(file_name)
    root = tree.getroot()

    nodes_dictionary = {}  # an empty dictionary

    # Find the 'Nodes' element with the target_name attribute
    nodes_element = root.find(f".//Nodes[@name='{node_name}']")

    # Check if the 'Nodes' element is found
    if nodes_element is not None:
        # Iterate over each 'node' element in the found 'Nodes' element
        for node in nodes_element.iter('node'):
            node_id = int(node.attrib['id'])
            coordinates = [float(coordinate) for coordinate in node.text.split(',')]  # list containing coordinates
            nodes_dictionary[node_id] = coordinates  # add the id as a key, the coordinates as value

    else:
        print(f"No 'Nodes' element with the name '{node_name}' found.")
    return nodes_dictionary


# TODO: get Dataset3D!!!!
def replace_node_in_new_feb_file(file_name, node_name, new_file_name, coordinates_list):
    """
    Replaces a node in an FEB file with the specified coordinates and saves the changes to a new FEB file.

    Parameters:
        file_name (str): The name of the original FEB file.
        node_name (str): The name of the node element to replace.
        new_file_name (str): The name of the new FEB file to save the changes.
        coordinates_list (list): A list of coordinates [x, y, z] for the new node.

    Returns:
        None

    Description:
        This function reads an existing FEB file specified by 'file_name' and finds the 'Mesh' element. It then creates
        a new FEB file specified by 'new_file_name' and replaces the existing 'Nodes' element with the specified
        'node_name' with a new 'Nodes' element that contains the provided coordinates. The 'Nodes' element to be
        replaced is identified by its 'name' attribute.

        The new 'Nodes' element is created with the provided 'node_name', and 'node' elements are added for each set
        of coordinates in the 'coordinates_list'. The 'id' attribute of each 'node' element is assigned sequentially
        starting from 1.

        Finally, the modified XML tree is written to the new FEB file, preserving the original FEB file.

    Notes:
        - If the 'Mesh' element or the 'Nodes' element with the specified 'node_name' is not found in the original FEB file,
          appropriate error messages are printed.
        - The original FEB file specified by 'file_name' remains unchanged. The changes are saved to the new FEB file
          specified by 'new_file_name'.
        - It is recommended to specify a different 'new_file_name' to avoid overwriting the original FEB file.

    Example:
        >>> replace_node_in_new_feb_file('input.feb', 'Nodes name', 'new_input.feb', [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])
    """
    #  create a copy of the original file
    shutil.copyfile(file_name, new_file_name)

    # Read the copied FEBio file
    tree = ET.parse(new_file_name)
    root = tree.getroot()

    # Find the 'Mesh' element
    mesh_element = root.find('Mesh')

    if mesh_element is not None:
        # Find the index of the 'Nodes' element with the specified 'name' attribute
        index = -1
        for i, nodes_element in enumerate(mesh_element):
            if nodes_element.tag == 'Nodes' and nodes_element.get('name') == node_name:
                index = i
                break

        # If the 'Nodes' element with the specified 'name' attribute is found, remove it
        if index != -1:
            mesh_element.remove(mesh_element[index])

            # Create a new 'Nodes' element and set the 'name' attribute
            new_nodes_element = ET.Element('Nodes')
            new_nodes_element.set('name', node_name)
            new_nodes_element.tail = "\n\t\t"
            new_nodes_element.text = "\n\t\t\t"

            # Iterate through the points in the coordinates_list and add them as 'node' elements
            for i, coordinates in enumerate(coordinates_list):
                node_element = ET.SubElement(new_nodes_element, 'node')
                node_element.set('id', str(i + 1))
                coordinates_text = f"{coordinates[0]}, {coordinates[1]}, {coordinates[2]}"
                node_element.text = coordinates_text
                node_element.tail = "\n\t\t\t"

            new_nodes_element[-1].tail = "\n\t\t"
            mesh_element.insert(index, new_nodes_element)

            # Write the updated XML tree to the new file
            tree.write(new_file_name, encoding='utf-8', xml_declaration=True)
        else:
            print(f"No 'Nodes' element with the name '{node_name}' found.")
    else:
        print("No 'Mesh' element found.")


# Append new one at the end.
# def write_node_to_feb_file(file_name, node_name, points_list):
#     # Read the existing FEBio file
#     tree = ET.parse(file_name)
#     root = tree.getroot()
#
#     # Create a new 'Nodes' element and set the 'name' attribute
#     nodes_element = ET.SubElement(root, 'Nodes')
#     nodes_element.set('name', node_name)
#
#     # Iterate through the points in the coordinates_list and add them as 'node' elements
#     for i, coordinates in enumerate(points_list):
#         node_element = ET.SubElement(nodes_element, 'node')
#         node_element.set('id', str(i + 1))
#         # The f denotes that it's an f-string. The expressions inside the curly
#         # braces are evaluated at runtime and then formatted using the format
#         # string syntax. In this case, coordinates[0], coordinates[1], and
#         # coordinates[2] will be evaluated and inserted into the resulting string.
#         coordinates_text = f"{coordinates[0]}, {coordinates[1]}, {coordinates[2]}"
#         node_element.text = coordinates_text
#
#     # Write the updated XML tree back to the file
#     tree.write(file_name, encoding='utf-8', xml_declaration=True)

# ###############################################################


# TODO: get Dataset3D!!!! Not coordinates list!
def replace_node_in_feb_file(file_name, node_name, coordinates_list):
    """
    Replaces the coordinates of a specific 'Nodes' element in an FEBio file with new coordinates.

    Parameters:
        file_name (str): The name of the FEBio file.
        node_name (str): The name of the 'Nodes' element to replace.
        coordinates_list (list): A list of coordinate tuples [(x1, y1, z1), (x2, y2, z2), ...] for the new coordinates.

    Returns:
        None

    Description:
        This function reads the FEBio file specified by 'file_name' and finds the 'Mesh' element.
        It searches for the 'Nodes' element with the specified 'name' attribute and removes it if found.
        Then, a new 'Nodes' element is created with the same 'name' attribute, and 'node' elements are added with the new coordinates.
        The updated XML tree is then written back to the file.

        If the 'Mesh' element or the 'Nodes' element with the specified 'name' attribute is not found, an appropriate message is printed.

    Example:
        >>> file_name = "input.feb"
        >>> node_name = "MyNodes"
        >>> coordinates_list = [(1.0, 2.0, 3.0), (4.0, 5.0, 6.0), (7.0, 8.0, 9.0)]
        >>> replace_node_in_feb_file(file_name, node_name, coordinates_list)

    Note:
        - This function assumes that the FEBio file exists and is formatted correctly as an XML file.
        - The 'node_name' should match the 'name' attribute of the 'Nodes' element to be replaced.
        - The 'coordinates_list' should contain coordinate tuples in the order [(x1, y1, z1), (x2, y2, z2), ...].
        - The function modifies the FEBio file in-place and does not create a new file.
    """

    # Read the existing FEBio file
    tree = ET.parse(file_name)
    root = tree.getroot()

    # Find the 'Mesh' element
    mesh_element = root.find('Mesh')

    if mesh_element is not None:
        # Find the index of the 'Nodes' element with the specified 'name' attribute
        index = -1
        for i, nodes_element in enumerate(mesh_element):
            if nodes_element.tag == 'Nodes' and nodes_element.get('name') == node_name:
                index = i
                break

        # If the 'Nodes' element with the specified 'name' attribute is found, remove it
        if index != -1:
            mesh_element.remove(mesh_element[index])

            # Create a new 'Nodes' element and set the 'name' attribute
            new_nodes_element = ET.Element('Nodes')
            new_nodes_element.set('name', node_name)
            new_nodes_element.tail = "\n\t\t"
            new_nodes_element.text = "\n\t\t\t"

            # Iterate through the points in the coordinates_list and add them as 'node' elements
            for i, coordinates in enumerate(coordinates_list):
                node_element = ET.SubElement(new_nodes_element, 'node')
                node_element.set('id', str(i + 1))
                coordinates_text = f"{coordinates[0]}, {coordinates[1]}, {coordinates[2]}"
                node_element.text = coordinates_text
                node_element.tail = "\n\t\t\t"

            new_nodes_element[-1].tail = "\n\t\t"
            mesh_element.insert(index, new_nodes_element)

            # Write the updated XML tree back to the file
            tree.write(file_name, encoding='utf-8', xml_declaration=True)
        else:
            print(f"No 'Nodes' element with the name '{node_name}' found.")
    else:
        print("No 'Mesh' element found.")


def get_dataset_from_feb_file(file_name, node_name):
    """
    Extracts points from an FEB file and returns them as an instance of the DataSet3d class.

    Parameters:
        file_name (str): The name of the FEB file.
        node_name (str): The name of the node element in the FEB file.

    Returns:
        DataSet3d: An instance of DataSet3d containing the extracted points.

    Description:
        This function reads an FEB file specified by 'file_name' and extracts the points belonging to the specified 'node_name'.
        The 'node_name' is used to locate the 'Nodes' element within the FEB file.

        The function utilizes the 'extract_coordinates_list_from_feb' function to extract the coordinates of the nodes.
        The extracted points are then converted to a numpy array and stored in the 'points' variable.

        Finally, the function creates an instance of the DataSet3d class using the extracted x, y, and z coordinates from 'points'
        and returns it as the result.

    Example usage:
        >>> dataset = get_dataset_from_feb_file('input.feb', 'MyNodes')
    """
    points = np.array(extract_coordinates_list_from_feb(file_name, node_name))

    return DataSet3d(list(points[:, 0]), list(points[:, 1]), list(points[:, 2]))


# TODO: CHECK the return and add Val
def get_interconnections_feb(file_name, node_name):  # connections-between-material
    """
    Extracts the interconnections between nodes in a specified 'Nodes' element from an FEB file.

    Parameters:
        file_name (str): The name of the FEB file.
        node_name (str): The name of the 'Nodes' element from which interconnections should be extracted.

    Returns:
        list: A list of lists, where each sublist contains the node numbers connected to the corresponding node.

    Description:
        This function reads the FEB file specified by 'file_name' and searches for the 'Nodes' element with the specified 'node_name'.
        It extracts the interconnections between the nodes by parsing the subsequent 'Elements' element and its 'elem' elements.
        The extracted interconnections are returned as a list of lists, where each sublist contains the node numbers connected to the corresponding node.

        If the 'Nodes' element with the specified 'node_name' is not found, an empty list is returned.

    Example:
        >>> file_name = "input.feb"
        >>> node_name = "MyNodes"
        >>> connections = get_interconnections_feb(file_name, node_name)
        >>> print(connections)
        [[2, 3, 4], [1, 4], [1, 2, 4], [1, 2, 3]]

    Note:
        - This function assumes that the FEB file exists and is formatted correctly as an XML file.
        - The 'node_name' should match the 'name' attribute of the target 'Nodes' element.
        - The interconnections are based on the 'Elements' element and its 'elem' elements in the XML tree structure.
        - The function does not validate the connectivity or perform any checks on the interconnections.
    """

    connections = []
    number_of_nodes = len(extract_coordinates_list_from_feb(file_name, node_name))

    # creates a list of empty nodes
    for i in range(0, number_of_nodes):
        connections.append([])

    tree = ET.parse(file_name)
    root = tree.getroot()

    # Convert the XML tree into a list
    xml_elements = list(root.iter())

    # Find the 'Nodes' element with the target_name attribute
    for i, element in enumerate(xml_elements):
        if element.tag == "Nodes" and element.attrib.get('name') == node_name:
            for next_element in xml_elements[i + 1:]:
                if next_element.tag == "Elements":
                    for elem in next_element.iter('elem'):
                        temp_list = list(map(int, elem.text.split(',')))
                        connections = addToVals(connections, temp_list[1:])
                    break
            break

    return connections


def addToVals(connections, nums):
    """
    Adds connections between nodes to the existing list of connections.

    Parameters:
        connections (list): The existing list of connections.
        nums (list): A list of node numbers that should be connected.

    Returns:
        list: The updated list of connections.

    Description:
        This function takes an existing list of connections and adds additional connections between nodes based on the provided 'nums' list.
        The 'connections' list represents the connections between nodes, where each element at index 'i' corresponds to the connections of node 'i + 1'.
        The 'nums' list contains the node numbers that should be connected.

        If the length of 'nums' is less than 4, each node in 'nums' is connected to all other nodes in 'nums' that are not already connected to it.
        If the length of 'nums' is 4, a square pattern of connections is formed between the four nodes.
        If the length of 'nums' is not 2, 3, or 4, a RuntimeError is raised.

        The function modifies the 'connections' list in-place and returns the updated list.

    Note:
        - This function assumes that the node numbering starts from 1, so the node numbers in the 'connections' list and 'nums' list should be in the range of 1 to N, where N is the total number of nodes.

    Example usage:
        >>> connections = [[], [], []]
        >>> nums = [2, 3, 5]
        >>> updated_connections = addToVals(connections, nums)
    """
    if len(nums) < 4:
        for num in nums:
            # goto connection[num], add all unique in nums
            for neighbor in nums:
                if neighbor not in connections[num - 1] and neighbor != num:
                    connections[num - 1].append(neighbor)

    elif len(nums) == 4:
        for i, num in enumerate(nums):
            for j, neighbor in enumerate(nums):
                if neighbor not in connections[num - 1] and (
                        i + j) % 2 == 1:  # indices 0,1,2,3 and each is the corner of a square; do not want diagonal or self.
                    # all the ones we want to add are odd+even indices
                    # odd+odd or even+even only occur when adding diagonals or self
                    connections[num - 1].append(neighbor)

    else:
        raise (RuntimeError("Error retrieving connections; can only handle sets of 2, 3, or 4 values"))
    return connections
