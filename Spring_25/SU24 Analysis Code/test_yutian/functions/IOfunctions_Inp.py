from math import floor

import linecache
import numpy as np

from lib.workingWith3dDataSets import DataSet3d

'''
Function: openFile
'''


def openFile(file_name):
    """
    Opens a file and returns its content as a list of lines.

    Parameters:
        file_name (str): The name of the file to open.

    Returns:
        list: A list where each element is a stripped line from the file.

    Description:
        This function opens the file specified by 'file_name' and reads its content. Each line of the file is stored as
        an element in a list. The function then strips leading and trailing whitespaces from each line.

        The function returns the list of lines as the content of the file.

    Example:
        >>> content = openFile('input.txt')
        >>> print(content)
        ['Line 1', 'Line 2', 'Line 3']

    Note:
        - The function assumes that the file exists and can be successfully opened.
        - It is recommended to use this function to open text-based files.
    """
    with open(file_name) as f:
        content = f.readlines()
    content = [x.strip() for x in content]
    return content


'''
Function: extractNodesFromINP
'''


def extractNodesFromINP(file_name, part, nodes):
    """
    Extracts the coordinates of the specified nodes from a given part in an Abaqus input file.

    Parameters:
        file_name (str): The name of the .inp file.
        part (str): The name of the part from which nodes should be extracted.
        nodes (list): A list of node numbers to be extracted.

    Returns:
        list: A list of node coordinates.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and extracts the coordinates
        of the specified nodes from the given 'part'. The node coordinates are extracted from the 'TissueCoordinates'
        array generated by calling the 'extractPointsForPartFrom' function.

        The function iterates over the provided 'nodes' list and retrieves the coordinates for each node from the
        'TissueCoordinates' array. The extracted node coordinates are added to the 'NodeCoordinates' list.

        The function returns a list of node coordinates.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> nodes = [1, 3, 5]
        >>> node_coordinates = extractNodesFromINP(file_name, part, nodes)
        >>> print(node_coordinates)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
    """
    TissueCoordinates = np.array(extractPointsForPartFrom(file_name, part, get_connections=False))
    #    print(TissueCoordinates)
    NodeCoordinates = []
    for i in nodes:
        NodeCoordinates.append(TissueCoordinates[i - 1])
    return NodeCoordinates


'''
Function: extractPointsForPartFrom
'''


def extractPointsForPartFrom(file_name, part, get_connections=False):
    """
    Extracts the points for a specified part from an Abaqus input file. It can also optionally return the connections between the points.

    Parameters:
        file_name (str): The name of the .inp file.
        part (str): The name of the part from which points should be extracted.
        get_connections (bool, optional): If true, also returns the connections between points.

    Returns:
        list: A list of point coordinates, and optionally a dictionary of connections.

    Description:
        This function reads an Abaqus input file specified by 'file_name' and extracts the points belonging to the specified 'part'. The 'part' is identified using the '*Part, name=' keyword followed by the part name.

        The function iterates through the lines of the file and collects the point coordinates belonging to the 'part'. The coordinates are stored as a list of lists, where each inner list represents the [x, y, z] coordinates of a point.

        If the 'get_connections' parameter is set to True, the function also extracts the connections between points and returns them as a dictionary. The dictionary uses the node number as the key and the connected nodes as the value.

        The extracted data is returned as a list of point coordinates, and if requested, a dictionary of connections. If the 'part' is not found in the input file, an empty list is returned.

    Note:
        - This function assumes that the Abaqus input file follows a specific format with valid syntax. Unexpected or malformed file structures may lead to incorrect results or errors.

    Example usage:
        >>> extractPointsForPartFrom('input.inp', 'MyPart', get_connections=True)
    """
    # print(file_name)
    content = openFile(file_name)

    found = False
    line_index = 1
    part = "*Part, name=" + part
    line_vals = []
    # connection_vals = []
    conVal = {}
    started = False
    started_connections = False
    for line in content:
        if not found and part not in line:
            continue  # go to next line
        elif not found:
            found = True
        else:

            data = line.split(",")
            try:
                # if line contains the next expected node number
                if int(data[0]) == line_index:

                    # append data
                    started = True
                    if started_connections and get_connections:
                        # make a temp list contain the data in one line
                        temp = list(map(int, data[1:]))
                        # set the first item as a key and the after to be the value
                        conVal[temp[0]] = temp[1:]
                    else:

                        line_vals.append(data)

                    line_index += 1

                # if we have started parsing data and the next line is not our expected node number
                elif started:
                    # we have collected al the data
                    break
            # occurs at "*Node" after we have found part name
            except ValueError:
                if data[0] == "*Element" and get_connections:
                    started_connections = True
                    line_index = 1
                continue

    xyz_vals = []
    for data_point in line_vals:
        # the node values are strings and need to be converted to floats
        xyz_vals.append([float(data_point[1]), float(data_point[2]), float(data_point[3])])

    if get_connections:
        return xyz_vals, conVal
    else:
        return xyz_vals


'''
Function: extractPointsForPartFrom2
'''


def extractPointsForPartFrom2(file_name, part, get_connections=False):
    """
    Extracts the points for a specified part from a file and optionally retrieves the connections between nodes.

    Parameters:
        file_name (str): The name of the file to extract points from.
        part (str): The name of the part to extract points for.
        get_connections (bool, optional): Whether to also retrieve the connections between nodes. Default is False.

    Returns:
        tuple or list: If 'get_connections' is True, returns a tuple containing the following elements:
            - points (list): A list of lists, where each sublist represents the x, y, and z coordinates of a point.
            - connections (list): A list of lists, where each sublist represents the connections of a node.
        If 'get_connections' is False, returns a list of lists representing the x, y, and z coordinates of the points.

    Description:
        This function reads the content of the specified file and extracts the points belonging to the specified part.
        It searches for the part name preceded by "*Part, name=" to identify the start of the point data.
        The point data is expected to follow the format of node numbers and their corresponding x, y, and z coordinates.

        If 'get_connections' is True, the function also retrieves the connections between nodes. The connections are
        expected to follow the format of element numbers and their corresponding node numbers.

        The function returns the extracted points as a list of lists representing the x, y, and z coordinates.
        If 'get_connections' is True, it also returns the connections as a list of lists representing the connections of each node.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> points = extractPointsForPartFrom2(file_name, part)
        >>> print(points)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]

        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> points, connections = extractPointsForPartFrom2(file_name, part, get_connections=True)
        >>> print(points)
        [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
        >>> print(connections)
        [[2, 3], [1, 3], [1, 2]]

    Note:
        - This function assumes that the input file follows a specific format with node numbers and coordinates.
        - The part name should match the actual part name in the input file.
        - If 'get_connections' is set to True, the connections are expected to follow a specific format with element numbers and node numbers.
    """
    content = openFile(file_name)
    found = False
    line_index = 1
    part = "*Part, name=" + part
    line_vals = []
    connection_vals = []
    started = False
    started_connections = False
    for line in content:
        if not found and part not in line:
            continue  # go to next line
        elif not found:
            found = True
        else:

            data = line.split(",")
            try:
                # if line contains the next expected node number
                if (int)(data[0]) == line_index:

                    # append data
                    started = True
                    if started_connections and get_connections:
                        temp = list(map(int, data[1:]))
                        connection_vals.append(temp)


                    else:

                        line_vals.append(data)

                    line_index += 1

                # if we have started parsing data and the next line is not our expected node number
                elif started:
                    # we have collected al the data
                    break
            # occurs at "*Node" after we have found part name
            except ValueError:
                if data[0] == "*Element" and get_connections:
                    started_connections = True
                    line_index = 1
                    continue
                else:
                    continue

    xyz_vals = []
    for data_point in line_vals:
        # the node values are strings and need to be converted to floats
        xyz_vals.append([float(data_point[1]), float(data_point[2]), float(data_point[3])])

    if get_connections:
        return xyz_vals, connection_vals
    else:
        return xyz_vals


'''
Function: write_new_inp_file
'''


def write_new_inp_file(file_name, part, new_file_name, data_set):
    """
    Writes a new Abaqus input file (.inp) with updated point data for a specified part.

    Parameters:
        file_name (str): The name of the original Abaqus input file.
        part (str): The name of the part where the point data will be updated.
        new_file_name (str): The name of the new Abaqus input file to be created.
        data_set (DataSet3d): An instance of the DataSet3d class containing the updated point data.

    Returns:
        None

    Description:
        This function reads the content of the original Abaqus input file specified by 'file_name' and searches for the specified 'part' to identify the point data section.
        It creates a new Abaqus input file specified by 'new_file_name' and writes the updated point data to it.

        The updated point data is provided through an instance of the DataSet3d class named 'data_set'. It contains the x, y, and z coordinates of the new points.

        The function writes the new point data in the same format as the original file, with each line representing a point and its coordinates. The new point data replaces the existing data in the specified part.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> new_file_name = "output.inp"
        >>> data_set = DataSet3d([1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0])
        >>> write_new_inp_file(file_name, part, new_file_name, data_set)

    Note:
        - This function assumes that the input file is a valid Abaqus input file.
        - The 'part' name should match the actual part name in the input file.
        - The 'data_set' should be an instance of the DataSet3d class containing the same number of points as the original part.
        - The new Abaqus input file will be created with the specified 'new_file_name' and will contain the updated point data for the specified part.
    """
    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length

    content = openFile(file_name)
    new_file = open(new_file_name, 'w')
    write = False
    found = False
    part = "*Part, name=" + part
    index = 0
    max_index = data_set.number_of_points - 1
    for line in content:
        if write and max_index >= index:
            """
            The  node number is Justified right with a length of 7
            """
            line = (str(index + 1).rjust(node_pad) + ',' + str(data_set.xAxis[index]).rjust(data_pad) + ',' + str(
                data_set.yAxis[index]).rjust(data_pad) + ', ' + str(data_set.zAxis[index]).rjust(data_pad))
            new_file.write(line + "\n")
            index += 1
        else:
            new_file.write(line + "\n")

        if found and not write:
            write = True

        if part in line:
            found = True

    new_file.close()


'''
Function: write_part_to_inp_file
'''


def write_part_to_inp_file(file_name, part, data_set):
    """
    Writes the updated point data for a specified part to an Abaqus input file (.inp).

    Parameters:
        file_name (str): The name of the Abaqus input file.
        part (str): The name of the part where the point data will be updated.
        data_set (DataSet3d): An instance of the DataSet3d class containing the updated point data.

    Returns:
        None

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and searches for the specified 'part' to identify the point data section.
        It updates the point data for the specified part with the coordinates provided in the 'data_set' instance.

        The function writes the updated point data to the same input file, overwriting the original data. The new point data is written in the same format as the original file, with each line representing a point and its coordinates.

    Example:
        >>> file_name = "input.inp"
        >>> part = "MyPart"
        >>> data_set = DataSet3d([1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0])
        >>> write_part_to_inp_file(file_name, part, data_set)

    Note:
        - This function assumes that the input file is a valid Abaqus input file.
        - The 'part' name should match the actual part name in the input file.
        - The 'data_set' should be an instance of the DataSet3d class containing the same number of points as the original part.
        - The function overwrites the original Abaqus input file with the updated point data for the specified part.
    """

    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length
    #    print(file_name)
    content = openFile(file_name)
    f = open(file_name, 'w')
    write = False
    found = False
    part = "*Part, name=" + part
    index = 0
    max_index = data_set.number_of_points - 1
    for line in content:
        if write and max_index >= index:
            """
            The  node number is Justified right with a length of 7
            """
            line = (str(index + 1).rjust(node_pad) + ',' + str(data_set.xAxis[index]).rjust(data_pad) + ',' + str(
                data_set.yAxis[index]).rjust(data_pad) + ', ' + str(data_set.zAxis[index]).rjust(data_pad))
            f.write(line + "\n")
            index += 1
        else:
            f.write(line + "\n")

        if found and not write:
            write = True

        if part in line:
            found = True

    f.close()


'''
Function: get_dataset_from_file

Extracts points but puts it into DataSet3d class
'''


def get_dataset_from_file(file_name, part_name):
    """
    Extracts points from a part in an Abaqus input file and returns them as an instance of the DataSet3d class.

    Parameters:
        file_name (str): The name of the .inp file.
        part_name (str): The name of the part from which points should be extracted.

    Returns:
        DataSet3d: An instance of DataSet3d containing the extracted points.

    Description:
        This function reads an Abaqus input file specified by 'file_name' and extracts the points belonging to the specified 'part_name'.
        The 'part_name' is identified using the '*Part, name=' keyword followed by the part name.

        The function utilizes the 'extractPointsForPartFrom' function to extract the points for the specified part.
        The extracted points are then converted to a numpy array and stored in the 'np_points' variable.

        Finally, the function creates an instance of the DataSet3d class using the extracted x, y, and z coordinates from 'np_points'
        and returns it as the result.

    Example usage:
        >>> dataset = get_dataset_from_file('input.inp', 'MyPart')
    """
    #    print(file_name, part_name)
    np_points = np.array(extractPointsForPartFrom(file_name, part_name))
    #    print(np_points)
    return DataSet3d(list(np_points[:, 0]), list(np_points[:, 1]), list(np_points[:, 2]))


'''
Function: get_interconnections
'''


def get_interconnections(file_name, part_name):  # connections-between-material
    """
    Retrieves the interconnections between nodes in a specified part from an Abaqus input file.

    Parameters:
        file_name (str): The name of the Abaqus input file.
        part_name (str): The name of the part from which interconnections should be extracted.

    Returns:
        list: A list of lists, where each sublist contains the node numbers connected to the corresponding node.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and searches for the specified 'part_name' to identify the interconnections between nodes.
        It extracts the node interconnections from the input file by parsing the lines after the "*Part, name=" section until it encounters the next section or element.

        The function returns a list of lists, where each sublist represents a node and contains the node numbers connected to that node.

    Example:
        >>> file_name = "input.inp"
        >>> part_name = "MyPart"
        >>> interconnections = get_interconnections(file_name, part_name)
        >>> print(interconnections)
        [[2, 3, 4], [1, 3, 4], [1, 2, 4], [1, 2, 3]]

    Note:
        - This function assumes that the input file is a valid Abaqus input file.
        - The 'part_name' should match the actual part name in the input file.
        - The interconnections are based on the assumption that they follow the node numbering section and precede the next section or element in the input file.
    """
    connections = []
    number_of_nodes = len(extractPointsForPartFrom(file_name, part_name))

    # creates a list of empty nodes
    for i in range(0, number_of_nodes):
        connections.append([])

    findLine = "*Part, name=" + part_name

    with open(file_name, 'r') as f:
        while (True):
            line = f.readline()
            if line.startswith(findLine):
                break
        while (True):
            line = f.readline()
            if line.startswith("*Element"):
                break
        while (True):
            if line.startswith("*Element"):  # we don't care
                line = f.readline()
            elif line.startswith("*"):  # done getting connections
                break
            else:
                strings = line.replace(" ", "").strip().split(",")
                nums = []
                for num in strings:
                    nums.append(int(num))

                connections = addToVals(connections, nums[1:])
                line = f.readline()

    return connections


'''
Function: addToVals
'''


def addToVals(connections, nums):
    """
    Adds connections between nodes to the existing list of connections.

    Parameters:
        connections (list): The existing list of connections.
        nums (list): A list of node numbers that should be connected.

    Returns:
        list: The updated list of connections.

    Description:
        This function takes an existing list of connections and adds additional connections between nodes based on the provided 'nums' list.
        The 'connections' list represents the connections between nodes, where each element at index 'i' corresponds to the connections of node 'i + 1'.
        The 'nums' list contains the node numbers that should be connected.

        If the length of 'nums' is less than 4, each node in 'nums' is connected to all other nodes in 'nums' that are not already connected to it.
        If the length of 'nums' is 4, a square pattern of connections is formed between the four nodes.
        If the length of 'nums' is not 2, 3, or 4, a RuntimeError is raised.

        The function modifies the 'connections' list in-place and returns the updated list.

    Note:
        - This function assumes that the node numbering starts from 1, so the node numbers in the 'connections' list and 'nums' list should be in the range of 1 to N, where N is the total number of nodes.

    Example usage:
        >>> connections = [[], [], []]
        >>> nums = [2, 3, 5]
        >>> updated_connections = addToVals(connections, nums)
    """

    if len(nums) < 4:
        for num in nums:
            # goto connection[num], add all unique in nums
            for neighbor in nums:
                if neighbor not in connections[num - 1] and neighbor != num:
                    connections[num - 1].append(neighbor)

    elif len(nums) == 4:
        for i, num in enumerate(nums):
            for j, neighbor in enumerate(nums):
                if neighbor not in connections[num - 1] and (
                        i + j) % 2 == 1:  # indices 0,1,2,3 and each is the corner of a square; do not want diagonal or self.
                    # all the ones we want to add are odd+even indices
                    # odd+odd or even+even only occur when adding diagonals or self
                    connections[num - 1].append(neighbor)

    else:
        raise (RuntimeError("Error retrieving connections; can only handle sets of 2, 3, or 4 values"))
    return connections


'''
Function: findLineNum

Returns the line number (not index) that a given string occurs in
'''


def findLineNum(file_location, string):
    """
    Finds the line number in a file where a specific string occurs.

    Parameters:
        file_location (str): The location of the file.
        string (str): The string to search for.

    Returns:
        int: The line number where the string occurs.

    Raises:
        EOFError: If the string is not found in the file.

    Description:
        This function opens the file specified by 'file_location' and iterates over each line, searching for the occurrence of the specified 'string'.
        If the string is found, the function returns the corresponding line number.
        If the string is not found, an EOFError is raised.

    Example:
        >>> file_location = "data.txt"
        >>> string = "Hello, World!"
        >>> line_number = findLineNum(file_location, string)
        >>> print(line_number)
        5

    Note:
        - The line numbers start from 1.
        - The function assumes that the file exists and is readable.
    """
    lineNum = 1
    f = open(file_location, 'r')
    for line in f:
        if string == line.strip():
            return lineNum
        lineNum += 1
    raise EOFError("String not found", file_location, string)


############### functions for reading csv file once it has been created with nodal coordinates
'''
Function: getFEAData
'''


def getFEAData(FileName, nodes):
    """
    Retrieves FEA data from a CSV file and extracts the coordinates of the specified number of nodes.

    Parameters:
        FileName (str): The name of the CSV file.
        nodes (int): The number of nodes to extract coordinates for.

    Returns:
        list: A list containing the extracted coordinates as separate arrays for x, y, and z axes.

    Description:
        This function reads the CSV file specified by 'FileName' using the numpy.genfromtxt() function, assuming that the data is comma-separated.
        It initializes empty arrays for x, y, and z coordinates with the size of 'nodes'.
        Then, it iterates over each node index and extracts the x, y, and z coordinates from the CSV data, assuming that the coordinates for each node are stored in consecutive rows with three values per row.
        The extracted coordinates are stored in the corresponding arrays.
        Finally, the function returns a list containing the arrays for x, y, and z coordinates.

    Example:
        >>> FileName = "data.csv"
        >>> nodes = 10
        >>> coordinates = getFEAData(FileName, nodes)
        >>> x_coords, y_coords, z_coords = coordinates
        >>> print(x_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(y_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(z_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]

    Note:
        - The CSV file should contain the coordinates of nodes in consecutive rows, with three values (x, y, z) per row.
        - The number of nodes specified should match the actual number of nodes in the CSV file.
    """
    csv = np.genfromtxt(FileName, delimiter=",")
    #    print(csv)
    #    [rows,columns] = csv.shape
    #    print(rows)
    #    print(columns)
    x = np.zeros(nodes)
    y = np.zeros(nodes)
    z = np.zeros(nodes)
    for i in range(0, nodes):
        x[i] = csv[i * 3]
        y[i] = csv[i * 3 + 1]
        z[i] = csv[i * 3 + 2]
    return [x, y, z]


'''
Function: getFEADataCoordinates
'''


def getFEADataCoordinates(FileName):
    """
    Retrieves FEA data coordinates from a CSV file and returns separate arrays for x, y, and z axes.

    Parameters:
        FileName (str): The name of the CSV file.

    Returns:
        list: A list containing the extracted coordinates as separate arrays for x, y, and z axes.

    Description:
        This function reads the CSV file specified by 'FileName' using the numpy.genfromtxt() function, assuming that the data is comma-separated.
        It checks if there are multiple rows of data and selects the last row for extraction. If there is only one row, it uses that row.
        It calculates the number of nodes based on the length of the data row divided by 3.
        It initializes empty arrays for x, y, and z coordinates with the size of 'nodes'.
        Then, it iterates over each node index and extracts the x, y, and z coordinates from the data row, assuming that the coordinates for each node are stored in consecutive positions with three values per node.
        The extracted coordinates are stored in the corresponding arrays.
        Finally, the function returns a list containing the arrays for x, y, and z coordinates.

    Example:
        >>> FileName = "data.csv"
        >>> coordinates = getFEADataCoordinates(FileName)
        >>> x_coords, y_coords, z_coords = coordinates
        >>> print(x_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(y_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(z_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]

    Note:
        - The CSV file should contain the coordinates of nodes in consecutive positions, with three values (x, y, z) per node.
        - The function assumes that the CSV file exists and is formatted correctly with the expected number of coordinates.
    """

    csv = np.genfromtxt(FileName, delimiter=",")

    # If there are multiple rows, get the last one
    try:
        data = csv[-1, :]
    except IndexError:
        data = csv

    nodes = floor((len(data) / 3))
    x = np.zeros(nodes)
    y = np.zeros(nodes)
    z = np.zeros(nodes)
    for i in range(0, nodes):
        x[i] = data[i * 3]
        y[i] = data[i * 3 + 1]
        z[i] = data[i * 3 + 2]
    return [x, y, z]


'''
Function: getInitialPositions
'''


def getInitialPositions(FileName, nodes):
    """
    Retrieves the initial positions of nodes from a CSV file and returns separate arrays for x, y, and z axes.

    Parameters:
        FileName (str): The name of the CSV file.
        nodes (int): The number of nodes in the CSV file.

    Returns:
        list: A list containing the extracted initial positions as separate arrays for x, y, and z axes.

    Description:
        This function reads the CSV file specified by 'FileName' using the numpy.genfromtxt() function, assuming that the data is comma-separated.
        It extracts the second column as the x-coordinate array, the third column as the y-coordinate array, and the fourth column as the z-coordinate array.
        The function assumes that the CSV file has rows with node indices and corresponding x, y, and z coordinates.
        The 'nodes' parameter specifies the number of nodes expected in the CSV file, which determines the size of the coordinate arrays.
        The extracted coordinate arrays are returned as a list containing separate arrays for x, y, and z axes.

    Example:
        >>> FileName = "data.csv"
        >>> nodes = 10
        >>> positions = getInitialPositions(FileName, nodes)
        >>> x_coords, y_coords, z_coords = positions
        >>> print(x_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(y_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]
        >>> print(z_coords)
        [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]

    Note:
        - The CSV file should contain rows with node indices and corresponding x, y, and z coordinates.
        - The 'nodes' parameter should be accurate to match the number of nodes in the CSV file.
        - The function assumes that the CSV file exists and is formatted correctly with the expected number of nodes and coordinates.
    """

    csv = np.genfromtxt(FileName, delimiter=",")
    x = np.array(csv[:, 1])
    y = np.array(csv[:, 2])
    z = np.array(csv[:, 3])
    return [x, y, z]


## ************************************************************************************************* ##
## ****************************Below is New Functions created by Yutian Yang************************ ##

'''
Function: get_points_below
'''


def get_points_below(file_name, part_name, threshold_percentage):
    """
    Retrieves the points below a specified threshold percentage along the z-axis from a given file and part.

    Parameters:
        file_name (str): The name of the file to extract points from.
        part_name (str): The name of the part to extract points from.
        threshold_percentage (float): The threshold percentage below which points are considered.

    Returns:
        tuple: A tuple containing the following elements:
            - filtered_points (list): A list of the original sort numbers of the filtered points.
            - filtered_count (int): The number of points below the threshold.
            - total_count (int): The total number of points in the part.

    Description:
        This function reads the content of the specified file and extracts the points belonging to the specified part.
        It then determines the minimum and maximum z-values among all the points. Based on the threshold percentage,
        a threshold z-value is calculated. Points whose z-coordinate is below the threshold are considered as filtered points.

        The function returns a tuple containing the original sort numbers of the filtered points, the count of filtered points,
        and the total count of points in the part.

    Example:
        >>> file_name = "input.inp"
        >>> part_name = "GivenPart"
        >>> threshold_percentage = 30
        >>> filtered_points, filtered_count, total_count = get_points_below(file_name, part_name, threshold_percentage)
        >>> print(filtered_points)
        [1, 3, 4, 6, 8, 10]
        >>> print(filtered_count)
        6
        >>> print(total_count)
        10
    """
    # Generate an array including all the points from the given file with part
    all_points = np.array(extractPointsForPartFrom(file_name, part_name))

    # Find the minimum and maximum z values
    min_z = np.min(all_points[:, 2])
    max_z = np.max(all_points[:, 2])

    # Calculate threshold z value
    threshold = threshold_percentage * 0.01 * (max_z - min_z) + min_z

    # Get the original sort number of each filtered point
    filtered_points = []
    for i, point in enumerate(all_points):
        if point[2] < threshold:
            filtered_points.append(i + 1)

    # Return the filtered points, filtered count, and total count
    return filtered_points, len(filtered_points), all_points.shape[0]


def get_points_x_from_mid(file_name, part_name, mid_x, threshold_x_from_mid):
    """
    Get the points within a specified range of x values from the mid_x point in a given file and part.

    Parameters:
        file_name (str): The name of the file containing the points.
        part_name (str): The name of the part containing the points.
        mid_x (float): The x-coordinate of the mid point.
        threshold_x_from_mid (float): The threshold distance from the mid point in the x-direction.

    Returns:
        tuple: A tuple containing:
            - filtered_points (list): The filtered points within the specified range.
            - filtered_count (int): The count of filtered points.
            - total_count (int): The total count of all points in the part.

    Description:
        This function reads the points from the specified file and part, and filters out the points that fall within
        the specified range of x values from the mid_x point. The range is determined by adding/subtracting the
        threshold_x_from_mid value from the mid_x value. The function returns the filtered points, the count of filtered
        points, and the total count of all points in the part.

    Example:
        >>> file_name = "points_file.csv"
        >>> part_name = "Part1"
        >>> mid_x = 5.0
        >>> threshold_x_from_mid = 2.0
        >>> filtered_points, filtered_count, total_count = get_points_x_from_mid(file_name, part_name, mid_x, threshold_x_from_mid)
        >>> print(filtered_points)
        [2, 3, 4, 5, 6]
        >>> print(filtered_count)
        5
        >>> print(total_count)
        10

    Notes:
        - The function assumes that the points file is in a format compatible with the `extractPointsForPartFrom()` function.
        - The part name (part_name) should match the exact name used in the file.
        - The mid_x value should correspond to the desired x-coordinate of the midpoint.
        - The threshold_x_from_mid value determines the range of x values to be considered around the midpoint.
        - The filtered_points list contains the indices of the filtered points, not the actual point coordinates.
    """
    # Generate an array including all the points from the given file with part
    all_points = np.array(extractPointsForPartFrom(file_name, part_name))
    # print(all_points)

    print("mid x: ", mid_x)

    # Calculate threshold z value
    threshold_left = mid_x - threshold_x_from_mid
    threshold_right = mid_x + threshold_x_from_mid

    # Get the original sort number of each filtered point
    filtered_points = []
    for i, point in enumerate(all_points):
        if threshold_left < point[0] < threshold_right:
            filtered_points.append(i + 1)

    # Return the filtered points, filtered count, and total count
    return filtered_points, len(filtered_points), all_points.shape[0]


'''
Function: write_Nset_to_inp_file
'''


def write_Nset_to_inp_file(file_name, part, Nset_num, section, material, Nset_list):
    """
    Write a new Nset (node set) to an input file.

    Parameters:
        file_name (str): The name of the input file to write to.
        part (str): The name of the part to modify.
        Nset_num (int): The number of the new Nset.
        section (str): The name of the section associated with the Nset.
        material (str): The material associated with the section.
        Nset_list (list): The list of node numbers to be included in the Nset.

    Description:
        This function modifies an input file by adding a new Nset (node set) to the specified part. The Nset is created
        with the given number (Nset_num) and includes the list of node numbers (Nset_list). Additionally, the function
        adds a section to the input file that associates the Nset with a specified section name (section) and material
        (material).

        The function reads the content of the original input file, finds the part to be modified, and inserts the new Nset
        and section at the appropriate locations. The modified content is then written back to the input file.

    Example:
        >>> file_name = "input_file.inp"
        >>> part = "Part1"
        >>> Nset_num = 1
        >>> section = "Section1"
        >>> material = "Material1"
        >>> Nset_list = [1, 2, 3, 4, 5]
        >>> write_Nset_to_inp_file(file_name, part, Nset_num, section, material, Nset_list)

    Notes:
        - The function assumes that the input file follows the INP format used by Abaqus software.
        - The part name (part) should match the exact name used in the input file.
        - The Nset number (Nset_num) should be unique and not conflict with existing Nsets.
        - The section name (section) and material (material) should match the names defined in the input file.
        - The Nset_list should contain valid node numbers corresponding to the nodes in the specified part.
    """

    node_pad = 3  # how big of a space to leave for the data
    line_pad = 16  # how many number in each line

    # print(file_name)

    content = openFile(file_name)

    part = "*Part, name=" + part
    index = 0
    max_index = len(Nset_list) - 1

    with open(file_name, 'w') as f:
        write = False
        found = False
        found_Nset = False
        found_section = False
        section_written = False

        for line in content:
            if part in line:
                found = True

            if found and ("*Nset, nset=" in line):
                found_Nset = True

            if found_Nset and ("** Section:" in line):
                found_section = True

            if found_Nset and not write:
                Nset = "*Nset, nset=_PickedSet" + str(Nset_num) + ", internal, generate" + "\n"
                f.write(Nset)
                write = True

            if write and max_index >= index:
                """
                The  node number is Justified right with a length of 4
                """
                for i in range(0, len(Nset_list), line_pad):
                    Nset_line = ', '.join(str(number).rjust(node_pad) for number in Nset_list[i:i + line_pad])
                    f.write(Nset_line + "\n")
                    index += line_pad
                print("Successfully insert new Nset", Nset_num)

            elif found_section and not section_written:
                section_line = "** Section: " + section + "\n" + "*Shell Section, elset=_PickedSet" + str(Nset_num) + ", material=" + str(material) + "\n" + "2., 5"
                f.write(section_line + "\n")
                section_written = True
                print("Successfully insert new Section", section)

            f.write(line + "\n")

    '''
    Function: write_new_part_to_inp_file
    '''


def get_dis_Nset_points_list(file_name, part_name, section_name):
    """
    Retrieves a list of node indices from an Abaqus input file (.inp) belonging to a specified dissection Nset.

    Parameters:
        file_name (str): The path to the Abaqus input file (.inp).
        part_name (str): The name of the part where the dissection Nset is located.
        section_name (str): The name of the dissection section.

    Returns:
        list or None: A list of node indices belonging to the dissection Nset, or None if the section is not found.

    Description:
        This function reads the content of the Abaqus input file specified by 'file_name' and searches for the specified 'part_name' and 'section_name' to identify the dissection Nset. The Nset is identified by the '*Nset, nset=' keyword followed by the Nset number.

        The function retrieves the node indices belonging to the dissection Nset by parsing the lines after the Nset definition until it encounters the next section or Nset. The node indices are returned as a list.

        If the specified 'section_name' is not found within the 'part_name', the function prints an error message and returns None.

    Example:
        >>> node_indices = get_dis_Nset_points_list('input.inp', 'MyPart', 'MySection')

    Note:
        - This function assumes that the input file is a valid Abaqus .inp file.
        - The 'part_name' and 'section_name' should match the actual part and section names in the input file.
        - Ensure that the dissection Nset is correctly defined using the '*Nset, nset=' keyword.
        - The function retrieves node indices based on the assumption that they follow the Nset definition and precede the next section or Nset in the input file.
    """
    content = openFile(file_name)
    part = "*Part, name=" + str(part_name)
    dis_section = "** Section: " + str(section_name) + "_dis"

    found_part = False
    found_section = False
    line_number = 0
    set_numbers = {}

    for line in content:
        line_number += 1
        if part in line:
            found_part = True
        if found_part and "*Nset, nset=_PickedSet" in line:
            set_number = line.split("_PickedSet")[1].split(",")[0].strip()
            set_numbers[set_number] = line_number

        if found_part and dis_section in line:
            found_section = True
            break

    if not found_section:
        print("No " + str(section_name) + "_dis found!")
        return None

    line_number += 1
    line = linecache.getline(file_name, line_number)
    exclude_set_number = line.split("_PickedSet")[1].split(",")[0].strip()
    exclude_points_list = []

    line_number = set_numbers[exclude_set_number]
    line = linecache.getline(file_name, line_number + 1)

    while "*Elset, elset=" not in line and "*Nset, nset=" not in line:
        numbers = line.strip().split(",")
        numbers = [int(num.strip()) for num in numbers]
        exclude_points_list.extend(numbers)
        line_number += 1
        line = linecache.getline(file_name, line_number)

    return exclude_points_list


def exclude_points_in_list(original_list, exclude_list):
    """
    Excludes numbers from an original list based on an exclude list and returns a new list.

    Parameters:
        original_list (list): The original list of numbers.
        exclude_list (list): The list of numbers to be excluded.

    Returns:
        list: A new list that contains numbers from the original list excluding those present in the exclude list.

    Example:
        >>> original_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        >>> exclude_list = [3, 5, 7]
        >>> result_list = exclude_points_in_list(original_list, exclude_list)
        >>> print(result_list)
        [1, 2, 4, 6, 8, 9, 10]
    """
    return [num for num in original_list if num not in exclude_list]


def write_points_below_excluded_to_inp(file_name, part_name, threshold_percent_from_bot, Nset_num, section_name, material):
    """
    Write the points below a certain threshold percentage from the bottom to an INP file.

    Parameters:
        file_name (str): The name of the INP file to write the points to.
        part_name (str): The name of the part containing the points.
        threshold_percent_from_bot (float): The threshold percentage from the bottom to exclude points.
        Nset_num (int): The Nset number to assign to the excluded points.
        section_name (str): The section name to assign to the excluded points.
        material (str): The material to assign to the section.

    Returns:
        None

    Description:
        This function writes the points below a specified threshold percentage from the bottom of a part to an INP file.
        It first gets the points below the threshold using the `get_points_below()` function. Then, it retrieves the
        excluded points from the INP file using the `get_dis_Nset_points_list()` function. It further filters out any
        points that are already excluded. Finally, it calls the `write_Nset_to_inp_file()` function to write the filtered
        points to the INP file.

    Example:
        >>> file_name = "example.inp"
        >>> part_name = "Part1"
        >>> threshold_percent_from_bot = 20.0
        >>> Nset_num = 1
        >>> section_name = "Section1"
        >>> material = "Material1"
        >>> write_points_below_excluded_to_inp(file_name, part_name, threshold_percent_from_bot, Nset_num, section_name, material)

    Notes:
        - The INP file must exist and be accessible for writing.
        - The part name (part_name) should match the exact name used in the INP file.
        - The threshold_percent_from_bot value represents the percentage of points to exclude from the bottom of the part.
        - The Nset_num value is used to assign a unique Nset number to the excluded points.
        - The section_name is the name to assign to the excluded points' section.
        - The material is the material to assign to the section.
        - The function assumes that the `get_points_below()`, `get_dis_Nset_points_list()`, and `write_Nset_to_inp_file()`
          functions are defined elsewhere in the codebase.
    """

    original_list = get_points_below(file_name, part_name, threshold_percent_from_bot)[0]
    exclude_list = get_dis_Nset_points_list(file_name, part_name, section_name)
    excluded_list = exclude_points_in_list(original_list, exclude_list)
    write_Nset_to_inp_file(file_name, part_name, Nset_num, section_name, material, excluded_list)


def write_points_x_from_mid_excluded_to_inp(file_name, part_name, mid_x, threshold_x_from_mid, Nset_num, section_name, material):
    """
    Write excluded points (based on x-coordinate from the mid-point) to an input file as a new Nset.

    Parameters:
        file_name (str): The name of the input file to write to.
        part_name (str): The name of the part containing the points.
        mid_x (float): The x-coordinate of the mid-point.
        threshold_x_from_mid (float): The threshold distance from the mid-point of x for exclusion.
        Nset_num (int): The number of the new Nset.
        section_name (str): The name of the section associated with the Nset.
        material (str): The material associated with the section.

    Description:
        This function identifies points in the specified part that have x-coordinates within a threshold distance from
        the mid-point of x. It excludes those points from the original list of points and writes the remaining points as a new
        Nset (node set) to the input file. The new Nset is associated with the specified section and material.

        The function utilizes other utility functions to extract the original list of points, exclude points based on
        section membership, and write the new Nset to the input file.

    Example:
        >>> file_name = "input_file.inp"
        >>> part_name = "Part1"
        >>> mid_x = 5.0
        >>> threshold_x_from_mid = 1.0
        >>> Nset_num = 1
        >>> section_name = "Section1"
        >>> material = "Material1"
        >>> write_points_x_from_mid_excluded_to_inp(file_name, part_name, mid_x, threshold_x_from_mid, Nset_num, section_name, material)

    Notes:
        - The function assumes that the input file follows the INP format used by Abaqus software.
        - The part name (part_name) should match the exact name used in the input file.
        - The x-coordinate of the mid-point (mid_x) should be within the range of x-coordinates in the specified part.
        - The threshold distance (threshold_x_from_mid) should be a positive value.
        - The Nset number (Nset_num) should be unique and not conflict with existing Nsets.
        - The section name (section_name) and material (material) should match the names defined in the input file.
    """

    original_list = get_points_x_from_mid(file_name, part_name, mid_x, threshold_x_from_mid)[0]
    exclude_list = get_dis_Nset_points_list(file_name, part_name, section_name)
    excluded_list = exclude_points_in_list(original_list, exclude_list)
    write_Nset_to_inp_file(file_name, part_name, Nset_num, section_name, material, excluded_list)


def write_new_part_to_inp_file(file_name, part, element_type, points_list, element_list):
    """
    Writes a new part to an existing .inp file (Abaqus input file).

    Parameters:
        file_name (str): The path to the existing .inp file.
        part (str): The name of the new part.
        element_type (str): The type of the elements in the new part.
        points_list (list of 3 floats): A list of the nodes' coordinates.
            Each node is represented as a list of three coordinates [x, y, z].
        element_list (list of ints): A list of the element definitions.
            Each element is defined by three node indices (assuming triangular elements).

    Returns:
        None

    Description:
        This function reads the content of the existing .inp file and writes the new part information before the
        first occurrence of "*Part, name=". The new part information includes the nodes (coordinates) and elements
        (node indices). Each line in the file is padded to ensure proper alignment.

    Note:
        - If the file does not exist or cannot be opened due to insufficient permissions, an error message is printed, and the function returns immediately without making any changes.

    Example:
        >>> write_new_part_to_inp_file('existing_file.inp', 'NewPart', 'C3D4', [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0]], [1, 2, 3])
    """
    element_pad = 4
    node_pad = 7  # how big of a space to leave for the data
    data_pad = 13  # this insures that of a number is 3 digits long it will be padded with spaces to the specified justifaction to maintian the given length
    #    print(file_name)

    content = openFile(file_name)
    with open(file_name, 'w') as f:
        found = False
        first_part = "*Part, name="

        for line in content:
            if first_part in line:
                found = True

            if found:
                part_line = "*Part, name=" + part
                f.write(part_line + "\n")
                f.write("*Node\n")
                for i in range(len(points_list)):
                    coordinates_line = (
                            str(i + 1).rjust(node_pad) + ', '
                            + str(points_list[i][0]).rjust(data_pad) + ', '
                            + str(points_list[i][1]).rjust(data_pad) + ', '
                            + str(points_list[i][2]).rjust(data_pad))
                    f.write(coordinates_line + "\n")
                print("Successfully insert the new part with the coordinates!")

                element = "*Element, type=" + str(element_type)
                f.write(element + "\n")

                for i in range(0, len(element_list), 2):
                    element_line = str(i // 3 + 1)  # add line number
                    if i < len(element_list):
                        element_line += ', ' + str(element_list[i]).rjust(element_pad)
                    if i + 1 < len(element_list):
                        element_line += ', ' + str(element_list[i + 1]).rjust(element_pad)
                    f.write(element_line + "\n")

                print("Successfully insert the new Element")

                end = "*End Part\n" + "**"
                f.write(end + "\n")
                found = False
            f.write(line + "\n")

    print("Successfully insert!")


# *************************************************************************************************************************
def getBnodes(file_location,
              BoundaryTissue):  # look for *Boundary and grab the next line after dropping the _ and only grabbing PickedSET### storing them in an array
    BNodes = []
    boundarySets = []
    with open(file_location, 'r') as file:
        line = "h"
        while "** BOUNDARY CONDITIONS" not in line:
            line = next(file)
        while "** INTERACTIONS" not in line:
            if "*Boundary" in line:
                boundarySets.append(next(file).split(",")[0])
            line = next(file)

    with open(file_location, 'r') as file:  # items are above *Boundary lines, must be reopened
        line = "line"
        while True:
            if isBoundaryLine(boundarySets, line):
                material = getName(line)
                if BoundaryTissue in material:

                    if "generate" in line:  # then it is parameters for an instruction
                        instructions = getNodes(file, line)
                        start = instructions[0]
                        end = instructions[1]
                        increment = instructions[2]
                        nodes = np.arange(start, end + 1, increment).tolist()
                        BNodes = BNodes + nodes

                    else:  # it's just a list of nodes
                        newNodes = getNodes(file, line)
                        for n in newNodes:
                            if n not in BNodes:
                                BNodes.append(n)
                else:
                    del line
                try:
                    line = next(file)
                except StopIteration:
                    break
            else:
                try:
                    line = next(file)
                except StopIteration:
                    break
        # BNodes.sort()
    return BNodes


def isBoundaryLine(boundarySets, line):
    if "*Nset" in line:
        line = line.split(", ")
        name = line[1].split("=")[1]  # selects _PickedSet5 from nset=_PickedSet5
        if name in boundarySets:
            return True
    return False


def getNodes(file, line):
    numberLines = []  # lines containing lists of numbers in the INP file
    line = next(file)
    while "*" not in line:
        numberLines.append(line)
        line = next(file)

    nodeIDs = []
    for line in numberLines:
        parseNumsFromCSV(nodeIDs, line)
    return nodeIDs


def getName(line):
    line = line.split(", ")
    name = line[3].split("=")[1].strip()  # selects _PickedSet5 from nset=_PickedSet5
    return name


def parseNumsFromCSV(nodeIDs, line):
    line.replace(" ", "")  # delete spaces
    numList = line.split(",")
    for x in numList:
        nodeIDs.append(int(x))  # int(x) converts it from string to integer
